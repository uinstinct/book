<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Iterating over More Complex Data</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href=".././mdbook-admonish.css">

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../01_introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="../getting_started/index.html"><strong aria-hidden="true">2.</strong> Getting Started</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../getting_started/leptos_dx.html"><strong aria-hidden="true">2.1.</strong> Leptos DX</a></li><li class="chapter-item expanded "><a href="../getting_started/community_crates.html"><strong aria-hidden="true">2.2.</strong> The Leptos Community and leptos-* Crates</a></li></ol></li><li class="chapter-item expanded "><a href="../view/index.html"><strong aria-hidden="true">3.</strong> Part 1: Building User Interfaces</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../view/01_basic_component.html"><strong aria-hidden="true">3.1.</strong> A Basic Component</a></li><li class="chapter-item expanded "><a href="../view/02_dynamic_attributes.html"><strong aria-hidden="true">3.2.</strong> Dynamic Attributes</a></li><li class="chapter-item expanded "><a href="../view/03_components.html"><strong aria-hidden="true">3.3.</strong> Components and Props</a></li><li class="chapter-item expanded "><a href="../view/04_iteration.html"><strong aria-hidden="true">3.4.</strong> Iteration</a></li><li class="chapter-item expanded "><a href="../view/04b_iteration.html" class="active"><strong aria-hidden="true">3.5.</strong> Iterating over More Complex Data</a></li><li class="chapter-item expanded "><a href="../view/05_forms.html"><strong aria-hidden="true">3.6.</strong> Forms and Inputs</a></li><li class="chapter-item expanded "><a href="../view/06_control_flow.html"><strong aria-hidden="true">3.7.</strong> Control Flow</a></li><li class="chapter-item expanded "><a href="../view/07_errors.html"><strong aria-hidden="true">3.8.</strong> Error Handling</a></li><li class="chapter-item expanded "><a href="../view/08_parent_child.html"><strong aria-hidden="true">3.9.</strong> Parent-Child Communication</a></li><li class="chapter-item expanded "><a href="../view/09_component_children.html"><strong aria-hidden="true">3.10.</strong> Passing Children to Components</a></li><li class="chapter-item expanded "><a href="../view/builder.html"><strong aria-hidden="true">3.11.</strong> No Macros: The View Builder Syntax</a></li></ol></li><li class="chapter-item expanded "><a href="../reactivity/index.html"><strong aria-hidden="true">4.</strong> Reactivity</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../reactivity/working_with_signals.html"><strong aria-hidden="true">4.1.</strong> Working with Signals</a></li><li class="chapter-item expanded "><a href="../reactivity/14_create_effect.html"><strong aria-hidden="true">4.2.</strong> Responding to Changes with create_effect</a></li><li class="chapter-item expanded "><a href="../reactivity/interlude_functions.html"><strong aria-hidden="true">4.3.</strong> Interlude: Reactivity and Functions</a></li></ol></li><li class="chapter-item expanded "><a href="../testing.html"><strong aria-hidden="true">5.</strong> Testing</a></li><li class="chapter-item expanded "><a href="../async/index.html"><strong aria-hidden="true">6.</strong> Async</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../async/10_resources.html"><strong aria-hidden="true">6.1.</strong> Loading Data with Resources</a></li><li class="chapter-item expanded "><a href="../async/11_suspense.html"><strong aria-hidden="true">6.2.</strong> Suspense</a></li><li class="chapter-item expanded "><a href="../async/12_transition.html"><strong aria-hidden="true">6.3.</strong> Transition</a></li><li class="chapter-item expanded "><a href="../async/13_actions.html"><strong aria-hidden="true">6.4.</strong> Actions</a></li></ol></li><li class="chapter-item expanded "><a href="../interlude_projecting_children.html"><strong aria-hidden="true">7.</strong> Interlude: Projecting Children</a></li><li class="chapter-item expanded "><a href="../15_global_state.html"><strong aria-hidden="true">8.</strong> Global State Management</a></li><li class="chapter-item expanded "><a href="../router/index.html"><strong aria-hidden="true">9.</strong> Router</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../router/16_routes.html"><strong aria-hidden="true">9.1.</strong> Defining &lt;Routes/&gt;</a></li><li class="chapter-item expanded "><a href="../router/17_nested_routing.html"><strong aria-hidden="true">9.2.</strong> Nested Routing</a></li><li class="chapter-item expanded "><a href="../router/18_params_and_queries.html"><strong aria-hidden="true">9.3.</strong> Params and Queries</a></li><li class="chapter-item expanded "><a href="../router/19_a.html"><strong aria-hidden="true">9.4.</strong> &lt;A/&gt;</a></li><li class="chapter-item expanded "><a href="../router/20_form.html"><strong aria-hidden="true">9.5.</strong> &lt;Form/&gt;</a></li></ol></li><li class="chapter-item expanded "><a href="../interlude_styling.html"><strong aria-hidden="true">10.</strong> Interlude: Styling</a></li><li class="chapter-item expanded "><a href="../metadata.html"><strong aria-hidden="true">11.</strong> Metadata</a></li><li class="chapter-item expanded "><a href="../csr_wrapping_up.html"><strong aria-hidden="true">12.</strong> Client-Side Rendering: Wrapping Up</a></li><li class="chapter-item expanded "><a href="../ssr/index.html"><strong aria-hidden="true">13.</strong> Part 2: Server Side Rendering</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../ssr/21_cargo_leptos.html"><strong aria-hidden="true">13.1.</strong> cargo-leptos</a></li><li class="chapter-item expanded "><a href="../ssr/22_life_cycle.html"><strong aria-hidden="true">13.2.</strong> The Life of a Page Load</a></li><li class="chapter-item expanded "><a href="../ssr/23_ssr_modes.html"><strong aria-hidden="true">13.3.</strong> Async Rendering and SSR “Modes”</a></li><li class="chapter-item expanded "><a href="../ssr/24_hydration_bugs.html"><strong aria-hidden="true">13.4.</strong> Hydration Bugs</a></li></ol></li><li class="chapter-item expanded "><a href="../server/index.html"><strong aria-hidden="true">14.</strong> Working with the Server</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../server/25_server_functions.html"><strong aria-hidden="true">14.1.</strong> Server Functions</a></li><li class="chapter-item expanded "><a href="../server/26_extractors.html"><strong aria-hidden="true">14.2.</strong> Extractors</a></li><li class="chapter-item expanded "><a href="../server/27_response.html"><strong aria-hidden="true">14.3.</strong> Responses and Redirects</a></li></ol></li><li class="chapter-item expanded "><a href="../progressive_enhancement/index.html"><strong aria-hidden="true">15.</strong> Progressive Enhancement and Graceful Degradation</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../progressive_enhancement/action_form.html"><strong aria-hidden="true">15.1.</strong> &lt;ActionForm/&gt;s</a></li></ol></li><li class="chapter-item expanded "><a href="../deployment/index.html"><strong aria-hidden="true">16.</strong> Deployment</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../deployment/binary_size.html"><strong aria-hidden="true">16.1.</strong> Optimizing WASM Binary Size</a></li></ol></li><li class="chapter-item expanded "><a href="../islands.html"><strong aria-hidden="true">17.</strong> Guide: Islands</a></li><li class="chapter-item expanded "><a href="../appendix_reactive_graph.html"><strong aria-hidden="true">18.</strong> Appendix: How Does the Reactive System Work?</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="iterating-over-more-complex-data-with-for"><a class="header" href="#iterating-over-more-complex-data-with-for">Iterating over More Complex Data with <code>&lt;For/&gt;</code></a></h1>
<p>This chapter goes into iteration over nested data structures in a bit
more depth. It belongs here with the other chapter on iteration, but feel
free to skip it and come back if you’d like to stick with simpler subjects
for now.</p>
<h2 id="the-problem"><a class="header" href="#the-problem">The Problem</a></h2>
<p>I just said that the framework does not rerender any of the items in one of the
rows, unless the key has changed. This probably makes sense at first, but it can
easily trip you up.</p>
<p>Let’s consider an example in which each of the items in our row is some data structure.
Imagine, for example, that the items come from some JSON array of keys and values:</p>
<pre><code class="language-rust">#[derive(Debug, Clone)]
struct DatabaseEntry {
    key: String,
    value: i32,
}</code></pre>
<p>Let’s define a simple component that will iterate over the rows and display each one:</p>
<pre><code class="language-rust">#[component]
pub fn App() -&gt; impl IntoView {
	// start with a set of three rows
    let (data, set_data) = create_signal(vec![
        DatabaseEntry {
            key: &quot;foo&quot;.to_string(),
            value: 10,
        },
        DatabaseEntry {
            key: &quot;bar&quot;.to_string(),
            value: 20,
        },
        DatabaseEntry {
            key: &quot;baz&quot;.to_string(),
            value: 15,
        },
    ]);
    view! {
		// when we click, update each row,
		// doubling its value
        &lt;button on:click=move |_| {
            set_data.update(|data| {
                for row in data {
                    row.value *= 2;
                }
            });
			// log the new value of the signal
            logging::log!(&quot;{:?}&quot;, data.get());
        }&gt;
            &quot;Update Values&quot;
        &lt;/button&gt;
		// iterate over the rows and display each value
        &lt;For
            each=data
            key=|state| state.key.clone()
            let:child
        &gt;
            &lt;p&gt;{child.value}&lt;/p&gt;
        &lt;/For&gt;
    }
}</code></pre>
<blockquote>
<p>Note the <code>let:child</code> syntax here. In the previous chapter we introduced <code>&lt;For/&gt;</code>
with a <code>children</code> prop. We can actually create this value directly in the children
of the <code>&lt;For/&gt;</code> component, without breaking out of the <code>view</code> macro: the <code>let:child</code>
combined with <code>&lt;p&gt;{child.value}&lt;/p&gt;</code> above is the equivalent of</p>
<pre><code class="language-rust">children=|child| view! { &lt;p&gt;{child.value}&lt;/p&gt; }</code></pre>
</blockquote>
<p>When you click the <code>Update Values</code> button... nothing happens. Or rather:
the signal is updated, the new value is logged, but the <code>{child.value}</code>
for each row doesn’t update.</p>
<p>Let’s see: is that because we forgot to add a closure to make it reactive?
Let’s try <code>{move || child.value}</code>.</p>
<p>...Nope. Still nothing.</p>
<p>Here’s the problem: as I said, each row is only rerendered when the key changes.
We’ve updated the value for each row, but not the key for any of the rows, so
nothing has rerendered. And if you look at the type of <code>child.value</code>, it’s a plain
<code>i32</code>, not a reactive <code>ReadSignal&lt;i32&gt;</code> or something. This means that even if we
wrap a closure around it, the value in this row will never update.</p>
<p>We have three possible solutions:</p>
<ol>
<li>change the <code>key</code> so that it always updates when the data structure changes</li>
<li>change the <code>value</code> so that it’s reactive</li>
<li>take a reactive slice of the data structure instead of using each row directly</li>
</ol>
<h2 id="option-1-change-the-key"><a class="header" href="#option-1-change-the-key">Option 1: Change the Key</a></h2>
<p>Each row is only rerendered when the key changes. Our rows above didn’t rerender,
because the key didn’t change. So: why not just force the key to change?</p>
<pre><code class="language-rust">&lt;For
	each=data
	key=|state| (state.key.clone(), state.value)
	let:child
&gt;
	&lt;p&gt;{child.value}&lt;/p&gt;
&lt;/For&gt;</code></pre>
<p>Now we include both the key and the value in the <code>key</code>. This means that whenever the
value of a row changes, <code>&lt;For/&gt;</code> will treat it as if it’s an entirely new row, and
replace the previous one.</p>
<h3 id="pros"><a class="header" href="#pros">Pros</a></h3>
<p>This is very easy. We can make it even easier by deriving <code>PartialEq</code>, <code>Eq</code>, and <code>Hash</code>
on <code>DatabaseEntry</code>, in which case we could just <code>key=|state| state.clone()</code>.</p>
<h3 id="cons"><a class="header" href="#cons">Cons</a></h3>
<p><strong>This is the least efficient of the three options.</strong> Every time the value of a row
changes, it throws out the previous <code>&lt;p&gt;</code> element and replaces it with an entirely new
one. Rather than making a fine-grained update to the text node, in other words, it really
does rerender the entire row on every change, and this is expensive in proportion to how
complex the UI of the row is.</p>
<p>You’ll notice we also end up cloning the whole data structure so that <code>&lt;For/&gt;</code> can hold
onto a copy of the key. For more complex structures, this can become a bad idea fast!</p>
<h2 id="option-2-nested-signals"><a class="header" href="#option-2-nested-signals">Option 2: Nested Signals</a></h2>
<p>If we do want that fine-grained reactivity for the value, one option is to wrap the <code>value</code>
of each row in a signal.</p>
<pre><code class="language-rust">#[derive(Debug, Clone)]
struct DatabaseEntry {
    key: String,
    value: RwSignal&lt;i32&gt;,
}</code></pre>
<p><code>RwSignal&lt;_&gt;</code> is a “read-write signal,” which combines the getter and setter in one object.
I’m using it here because it’s a little easier to store in a struct than separate getters
and setters.</p>
<pre><code class="language-rust">#[component]
pub fn App() -&gt; impl IntoView {
	// start with a set of three rows
    let (data, set_data) = create_signal(vec![
        DatabaseEntry {
            key: &quot;foo&quot;.to_string(),
            value: create_rw_signal(10),
        },
        DatabaseEntry {
            key: &quot;bar&quot;.to_string(),
            value: create_rw_signal(20),
        },
        DatabaseEntry {
            key: &quot;baz&quot;.to_string(),
            value: create_rw_signal(15),
        },
    ]);
    view! {
		// when we click, update each row,
		// doubling its value
        &lt;button on:click=move |_| {
            data.with(|data| {
                for row in data {
                    row.value.update(|value| *value *= 2);
                }
            });
			// log the new value of the signal
            logging::log!(&quot;{:?}&quot;, data.get());
        }&gt;
            &quot;Update Values&quot;
        &lt;/button&gt;
		// iterate over the rows and display each value
        &lt;For
            each=data
            key=|state| state.key.clone()
            let:child
        &gt;
            &lt;p&gt;{child.value}&lt;/p&gt;
        &lt;/For&gt;
    }
}</code></pre>
<p>This version works! And if you look in the DOM inspector in your browser, you’ll
see that unlike in the previous version, in this version only the individual text
nodes are updated. Passing the signal directly into <code>{child.value}</code> works, as
signals do keep their reactivity if you pass them into the view.</p>
<p>Note that I changed the <code>set_data.update()</code> to a <code>data.with()</code>. <code>.with()</code> is the
non-cloning way of accessing a signal’s value. In this case, we are only updating
the internal values, not updating the list of values: because signals maintain their
own state, we don’t actual need to update the <code>data</code> signal at all, so the immutable
<code>.with()</code> is fine here.</p>
<blockquote>
<p>In fact, this version doesn’t update <code>data</code>, so the <code>&lt;For/&gt;</code> is essentially a static
list as in the last chapter, and this could just be a plain iterator. But the <code>&lt;For/&gt;</code>
is useful if we want to add or remove rows in the future.</p>
</blockquote>
<h3 id="pros-1"><a class="header" href="#pros-1">Pros</a></h3>
<p>This is the most efficient option, and fits directly with the rest of the mental model
of the framework: values that change over time are wrapped in signals so the interface
can respond to them.</p>
<h3 id="cons-1"><a class="header" href="#cons-1">Cons</a></h3>
<p>Nested reactivity can be cumbersome if you’re receiving data from an API or another
data source you don’t control, and you don’t want to create a different struct wrapping
each field in a signal.</p>
<h2 id="option-3-memoized-slices"><a class="header" href="#option-3-memoized-slices">Option 3: Memoized Slices</a></h2>
<p>Leptos provides a primitive called <a href="https://docs.rs/leptos/latest/leptos/fn.create_memo.html"><code>create_memo</code></a>,
which creates a derived computation that only triggers a reactive update when its value
has changed.</p>
<p>This allows you to create reactive values for subfields of a larger data structure,
without needing to wrap the fields of that structure in signals.</p>
<p>Most of the application can remain the same as the initial (broken) version, but the <code>&lt;For/&gt;</code>
will be updated to this:</p>
<pre><code class="language-rust">&lt;For
    each=move || data().into_iter().enumerate()
    key=|(_, state)| state.key.clone()
    children=move |(index, _)| {
        let value = create_memo(move |_| {
            data.with(|data| data.get(index).map(|d| d.value).unwrap_or(0))
        });
        view! {
            &lt;p&gt;{value}&lt;/p&gt;
        }
    }
/&gt;</code></pre>
<p>You’ll notice a few differences here:</p>
<ul>
<li>we convert the <code>data</code> signal into an enumerated iterator</li>
<li>we use the <code>children</code> prop explicitly, to make it easier to run some non-<code>view</code> code</li>
<li>we define a <code>value</code> memo and use that in the view. This <code>value</code> field doesn’t actually
use the <code>child</code> being passed into each row. Instead, it uses the index and reaches back
into the original <code>data</code> to get the value.</li>
</ul>
<p>Every time <code>data</code> changes, now, each memo will be recalculated. If its value has changed,
it will update its text node, without rerendering the whole row.</p>
<h3 id="pros-2"><a class="header" href="#pros-2">Pros</a></h3>
<p>We get the same fine-grained reactivity of the signal-wrapped version, without needing to
wrap the data in signals.</p>
<h3 id="cons-2"><a class="header" href="#cons-2">Cons</a></h3>
<p>It’s a bit more complex to set up this memo-per-row inside the <code>&lt;For/&gt;</code> loop rather than
using nested signals. For example, you’ll notice that we have to guard against the possibility
that the <code>data[index]</code> would panic by using <code>data.get(index)</code>, because this memo may be 
triggered to re-run once just after the row is removed. (This is because the memo for each row
and the whole <code>&lt;For/&gt;</code> both depend on the same <code>data</code> signal, and the order of execution for
multiple reactive values that depend on the same signal isn’t guaranteed.)</p>
<p>Note also that while memos memoize their reactive changes, the same
calculation does need to re-run to check the value every time, so nested reactive signals
will still be more efficient for pinpoint updates here.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../view/04_iteration.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../view/05_forms.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../view/04_iteration.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../view/05_forms.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
